from pathlib import Path
import io
import pandas as pd
from collections import OrderedDict
import shutil, os, sys
import re
import argparse
import numpy as np

def change_names(orig_name):

    new_str={'_False_True': '_FT',
             '_True_False': '_TF',
             '_True_True': '_TT',
             '16_-1_16_False_False': 'CLOUD16',
             '_2_False_False': 'U2',
             '_4_False_False': 'U4',
             '_6_False_False': 'U6',
             '_8_False_False': 'U8',

             }
    for key, val in new_str.items():
        if key in orig_name:
            x = orig_name.split(key)[0]
            if val == 'U2' or val == 'U4' or val == 'U6' or val == 'U8' or val == 'CLOUD16':
                x = val
            else:
                x = x + val
            return x

def get_accuracy(pattern):
    tmp = pattern.strip('\n').split('  ')
    top1_accuracy = tmp[0].split(':')[-1]
    top5_accuracy = tmp[2].split(':')[-1]
    return float(top1_accuracy), float(top5_accuracy)


def collect_accuracy_stats(input_folder):
    basepath = Path(input_folder)
    patterns = ['- Command line:','Pass 1:', '==> Top1']
    # if 'Pass 1:' then >=4; else: >=2
    accuracy_df = pd.DataFrame(columns=['name', 'top1', 'top5'])
    # for all directories
    for dirpath in basepath.glob('*/'):
        # get logfile
        filename = [f for f in os.listdir(dirpath) if '.log' in f][0]
        filepath = Path(os.path.join(dirpath,filename))
        if filepath.suffix == '.log':
        # if filepath is not None:
            found_pattern=[]
            for line in open(filepath):
                for pattern in patterns:
                    if re.search(pattern, line):
                        found_pattern.append(line)


            config = found_pattern[0].split('--qe-config-file')[-1].strip('\n').split('.yaml')[0].split('.csv')[0]
            config_name = Path(config).name
            config_name = change_names(config_name)
            found_pattern.pop(0)

            is_pass = False
            len_found_pattern = 0

            if not found_pattern:
                print(filepath.name)
                print('Runs crashed: {}'.format(config_name))

            elif 'Pass 1:' in found_pattern[0]:
                found_pattern.pop(0)
                len_found_pattern = len(found_pattern)
                is_pass = True
            else:
                is_pass = False
                len_found_pattern = len(found_pattern)

            if (is_pass and len_found_pattern >= 4) or \
                    (not is_pass and len_found_pattern >=2):
                tuple_accuracy = list(map(get_accuracy, found_pattern))
                if not tuple_accuracy:
                    print(filepath.name)
                    print('Runs crashed: {}'.format(config_name))
                    continue
            else:
                print(filepath.name)
                print('Runs crashed: {}'.format(config_name))
                continue

            top1_accuracy, top5_accuracy = tuple_accuracy[-1]
            # print('{},{},{}'.format(config,top1_accuracy, top5_accuracy))

            accuracy_df = accuracy_df.append({'name': config_name,
                                              'top1': top1_accuracy,
                                              'top5': top5_accuracy}, ignore_index=True)

    return accuracy_df

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--net-df', '-n', default='resnet50_20200521-174448', type=lambda s: s.lower(),
                        help=' Needs timestamp folder generated by autosplit algorithm ')

    parser.add_argument('--bw', '-b', default='3', type=lambda s: s.lower(),
                        help='default bandwidth folder = 3 Mbps')
    args = parser.parse_args()
    bw = args.bw
    logdir=args.net_df

    root_dir=os.getcwd()
    accuracy_folder= '{}/generated/quant_results/{}/logs'.format(root_dir,logdir)
    accuracy_df = collect_accuracy_stats(accuracy_folder)

    latency_file = '{}/generated/latency/{}/{}/latency_mse_stats.csv'.format(root_dir,logdir, bw)
    latency_mse_df = pd.read_csv(latency_file)
    merged_df = pd.merge(latency_mse_df, accuracy_df)
    u4_accuracy = merged_df[merged_df['name'] == 'U4']['top1'].tolist()[0]
    # Select only accuracies greater than U4.
    merged_df = merged_df[merged_df['top1'] >= u4_accuracy]
    merged_df.sort_values(by=['latency'])
    print(merged_df)
    merged_df.to_csv('{}/generated/quant_results/accuracy_{}.csv'.format(root_dir,logdir))
if __name__ == '__main__':
    main()
